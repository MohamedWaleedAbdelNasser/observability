package main

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"net/http"
	"sync"

	"github.com/gorilla/mux"
	"golang.org/x/oauth2"
)

const (
	clientID          = "my-oauth2-client"
	resourceServerURL = "http://localhost:8082"
	redirectURI       = "http://localhost:8080/callback"
)

var oauthConfig = &oauth2.Config{
	ClientID: clientID,
	Endpoint: oauth2.Endpoint{
		AuthURL:  "http://localhost:8081/authorize",
		TokenURL: "http://localhost:8081/token",
	},
	RedirectURL: redirectURI,
	Scopes:      []string{"read", "write", "delete"},
}

var (
	pkceStore  = make(map[string]PKCEData)
	storeMutex sync.RWMutex
)

type PKCEData struct {
	Verifier  string
	Challenge string
}

func generateState() string {
	b := make([]byte, 16)
	rand.Read(b)
	return base64.RawURLEncoding.EncodeToString(b)
}

func getChallengeFromVerifier(verifier string) string {
	return oauth2.S256ChallengeFromVerifier(verifier)
}

func handleStart(w http.ResponseWriter, r *http.Request) {
	log.Println("")
	log.Println("════════════════════════════════════════════════════════════════")
	log.Println("STARTING OAuth2 AUTHORIZATION CODE FLOW WITH PKCE")
	log.Println("════════════════════════════════════════════════════════════════")
	log.Println("")

	log.Println("[Client] STEP 1: Generating PKCE parameters using oauth2.GenerateVerifier()...")

	codeVerifier := oauth2.GenerateVerifier()

	codeChallenge := getChallengeFromVerifier(codeVerifier)

	state := generateState()

	log.Printf("[Client]  code_verifier (generated by oauth2.GenerateVerifier):  %s", codeVerifier)
	log.Printf("[Client]  code_challenge (SHA256 of verifier):                    %s", codeChallenge)
	log.Printf("[Client]  state (for CSRF protection):                            %s", state)
	log.Println("")

	storeMutex.Lock()
	pkceStore[state] = PKCEData{
		Verifier:  codeVerifier,
		Challenge: codeChallenge,
	}
	storeMutex.Unlock()

	log.Println("[Client] STEP 2: Building authorization request using oauth2.Config.AuthCodeURL()...")

	authURL := oauthConfig.AuthCodeURL(state, oauth2.S256ChallengeOption(codeVerifier))

	log.Printf("[Client]  Authorization URL generated")
	log.Printf("[Client]  oauth2.S256ChallengeOption() automatically added PKCE challenge")
	log.Println("[Client] Redirecting to Authorization Server...")
	log.Println("")

	http.Redirect(w, r, authURL, http.StatusFound)
}

func handleCallback(w http.ResponseWriter, r *http.Request) {
	log.Println("\n[Client] ========================================")
	log.Println("[Client] STEP 3: Received callback from Authorization Server")

	query := r.URL.Query()
	code := query.Get("code")
	state := query.Get("state")
	errorParam := query.Get("error")

	if errorParam != "" {
		log.Printf("[Client] ERROR: %s - %s", errorParam, query.Get("error_description"))
		http.Error(w, "Authorization failed", http.StatusBadRequest)
		return
	}

	if code == "" {
		log.Println("[Client] ERROR: No authorization code received")
		http.Error(w, "No authorization code", http.StatusBadRequest)
		return
	}

	log.Printf("[Client]  Received authorization code: %s", code[:20]+"...")
	log.Printf("[Client]  State: %s", state)
	log.Println("")

	storeMutex.RLock()
	pkceData, exists := pkceStore[state]
	storeMutex.RUnlock()

	if !exists {
		log.Println("[Client] ERROR: Invalid state parameter")
		http.Error(w, "Invalid state", http.StatusBadRequest)
		return
	}

	storeMutex.Lock()
	delete(pkceStore, state)
	storeMutex.Unlock()

	log.Println("[Client] STEP 4: Exchanging authorization code for access token...")
	log.Printf("[Client] Using oauth2.Config.Exchange() with oauth2.VerifierOption()")
	log.Printf("[Client] Code verifier being sent: %s", pkceData.Verifier[:20]+"...")

	ctx := context.Background()
	token, err := oauthConfig.Exchange(ctx, code, oauth2.VerifierOption(pkceData.Verifier))
	if err != nil {
		log.Printf("[Client] ERROR: Failed to exchange code: %v", err)
		http.Error(w, "Token exchange failed", http.StatusInternalServerError)
		return
	}

	log.Printf("[Client]  Received access token: %s", token.AccessToken[:20]+"...")
	log.Printf("[Client]  Token type: %s", token.TokenType)
	log.Printf("[Client]  Token expiry: %v", token.Expiry)
	log.Println("")

	log.Println("[Client] STEP 5: Calling Resource Server with access token...")
	log.Println("[Client] Using oauth2.Config.Client() to create authenticated HTTP client")

	client := oauthConfig.Client(ctx, token)

	resourceURL := fmt.Sprintf("%s/user/data", resourceServerURL)
	log.Printf("[Client] Making request to: %s", resourceURL)
	log.Println("[Client] (oauth2.Client automatically adds 'Authorization: Bearer <token>' header)")

	resp, err := client.Get(resourceURL)
	if err != nil {
		log.Printf("[Client] ERROR: Failed to call resource server: %v", err)
		http.Error(w, "Resource request failed", http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	resourceBody, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Printf("[Client] ERROR: Failed to read response: %v", err)
		http.Error(w, "Failed to read response", http.StatusInternalServerError)
		return
	}

	if resp.StatusCode != http.StatusOK {
		log.Printf("[Client] ERROR: Resource server returned %d: %s", resp.StatusCode, string(resourceBody))
		http.Error(w, "Resource request failed", http.StatusInternalServerError)
		return
	}

	log.Println("[Client]  Resource server response:")
	log.Printf("  %s", string(resourceBody))
	log.Println("")

	log.Println("════════════════════════════════════════════════════════════════")
	log.Println("DONE - OAuth2 AUTHORIZATION CODE FLOW WITH PKCE COMPLETED SUCCESSFULLY!")
	log.Println("════════════════════════════════════════════════════════════════")

	truncate := func(s string, maxLen int) string {
		if len(s) <= maxLen {
			return s
		}
		return s[:maxLen] + "..."
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	fmt.Fprintf(w, `
<!DOCTYPE html>
<html>
<head>
    <title>OAuth2 PKCE Success</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%%, #764ba2 100%%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        .header p {
            opacity: 0.9;
            font-size: 14px;
        }
        .content {
            padding: 30px;
        }
        .card {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .card h2 {
            font-size: 16px;
            font-weight: 600;
            color: #111827;
            margin-bottom: 12px;
        }
        .field {
            margin-bottom: 12px;
            font-size: 14px;
        }
        .field:last-child {
            margin-bottom: 0;
        }
        .label {
            color: #6b7280;
            display: inline-block;
            min-width: 140px;
            font-weight: 500;
        }
        .value {
            color: #111827;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            word-break: break-all;
        }
        pre {
            background: #1f2937;
            color: #f3f4f6;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.5;
        }
        .btn {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            text-decoration: none;
            font-weight: 500;
            transition: background 0.2s;
            text-align: center;
        }
        .btn:hover {
            background: #5568d3;
        }
        .footer {
            text-align: center;
            padding: 20px;
            border-top: 1px solid #e5e7eb;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1> OAuth2 Flow Completed</h1>
            <p>Authorization Code Flow with PKCE</p>
        </div>
        
        <div class="content">
            <div class="card">
                <h2>PKCE Parameters</h2>
                <div class="field">
                    <span class="label">Verifier:</span>
                    <span class="value">%s</span>
                </div>
                <div class="field">
                    <span class="label">Challenge:</span>
                    <span class="value">%s</span>
                </div>
            </div>

            <div class="card">
                <h2>Access Token</h2>
                <div class="field">
                    <span class="label">Token:</span>
                    <span class="value">%s</span>
                </div>
                <div class="field">
                    <span class="label">Type:</span>
                    <span class="value">%s</span>
                </div>
            </div>
            
            <div class="card">
                <h2>API Response</h2>
                <pre>%s</pre>
            </div>
        </div>

        <div class="footer">
            <a href="/start" class="btn">Run Again</a>
        </div>
    </div>
</body>
</html>
`,
		truncate(pkceData.Verifier, 50),
		truncate(pkceData.Challenge, 50),
		truncate(token.AccessToken, 40),
		token.TokenType,
		string(resourceBody))
}

func main() {
	r := mux.NewRouter()

	r.HandleFunc("/start", handleStart).Methods("GET")
	r.HandleFunc("/callback", handleCallback).Methods("GET")

	fmt.Println("════════════════════════════════════════════════════════════════")
	fmt.Println("OAuth2 CLIENT WITH PKCE (using golang.org/x/oauth2)")
	fmt.Println("════════════════════════════════════════════════════════════════")
	fmt.Println("Starting Client on http://localhost:8080")
	fmt.Println("")
	fmt.Println("Endpoints:")
	fmt.Println("  GET /start    - Start OAuth2 flow")
	fmt.Println("  GET /callback - OAuth2 redirect URI")
	fmt.Println("Waiting for requests...")

	log.Fatal(http.ListenAndServe(":8080", r))
}
